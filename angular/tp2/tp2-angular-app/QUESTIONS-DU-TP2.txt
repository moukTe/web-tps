1. src/app

Contient le cœur de l’application Angular.

Inclut les composants, services, modules, directives, et pipes créés par le développeur.

Exemple : app.component.ts est le composant racine de l’application.

2. src/assets

Répertoire pour les ressources statiques telles que : images, fichiers JSON, polices, icônes, vidéos, etc.

Ces fichiers sont copiés tels quels dans le build final.

3. src/environments

Contient les fichiers de configuration pour différents environnements :

environment.ts → configuration par défaut (développement)

environment.prod.ts → configuration pour la production

Permet de changer les paramètres comme l’API URL selon l’environnement.

4. src/main.ts

Point d’entrée de l’application Angular.

Angular démarre l’application en bootstrappant le module principal (AppModule).

Contient généralement :

platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.error(err));

5. src/index.html

Page HTML principale qui sera chargée par le navigateur.

Contient la balise <app-root> où Angular injectera l’application.

Sert aussi à inclure les fichiers CSS globaux, meta tags et scripts externes.

6. angular.json

Fichier de configuration du projet Angular CLI.

Définit :

Les chemins des fichiers sources

Les options de build et de serve

Les configurations pour les environnements (dev/prod)

Angular CLI utilise ce fichier pour compiler, servir et déployer l’application.

7. package.json

Fichier gestionnaire de dépendances Node.js.

Contient :

Les dépendances du projet (dependencies) et de développement (devDependencies)

Les scripts (npm start, npm build, npm test)

Les informations sur le projet (nom, version, licence)

8. tsconfig.json

Fichier de configuration TypeScript.

Définit :

Les options de compilation TypeScript (target, module, strict, etc.)

Les chemins et exclusions pour compiler correctement le code Angular.

activite 4 :
@Component({
  selector: 'app-profil',
  standalone: true,
  imports: [/* FormsModule */],  // Commenté
  templateUrl: './profil.html',
  styleUrl: './profil.css'
})


Pourquoi l'importation de FormsModule est nécessaire :

FormsModule contient la directive ngModel qui permet la liaison bidirectionnelle des données [(ngModel)]
Sans FormsModule, Angular ne reconnaît pas ngModel et génère une erreur indiquant que cette directive n'existe pas
FormsModule fournit également d'autres fonctionnalités comme la validation de formulaires et la gestion de l'état des formulaires

Rôle du composant standalone dans la gestion des dépendances :

Dans l'approche standalone (moderne), chaque composant gère ses propres dépendances
Le composant importe directement les modules dont il a besoin dans son décorateur @Component
Cela remplace l'ancien système où un AppModule centralisé gérait toutes les dépendances
Avantages : meilleure modularité, chargement plus rapide, et code plus facile à maintenir

3. Restauration :

Décommentez l'importation de FormsModule dans profil.ts :

typescriptimport { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-profil',
  standalone: true,
  imports: [FormsModule],  // Restauré
  templateUrl: './profil.html',
  styleUrl: './profil.css'
})

Pourquoi il est nécessaire d'importer les composants dans l'approche standalone :

Isolation et modularité : Chaque composant standalone doit explicitement déclarer ses dépendances. Cela rend le code plus clair et plus maintenable.
Angular ne devine pas : Angular ne peut pas deviner quels composants vous voulez utiliser. Vous devez lui indiquer explicitement en les ajoutant au tableau imports.
Optimisation : En important uniquement ce qui est nécessaire, Angular peut optimiser le chargement et réduire la taille du bundle final (tree-shaking).
Encapsulation : Chaque composant est autonome et portable. Vous pouvez facilement réutiliser un composant dans différents projets sans dépendances cachées.
Différence avec l'ancien système : Dans l'approche NgModule (ancienne), les composants étaient déclarés dans un module centralisé. Avec standalone, chaque composant gère ses propres imports directement.

En résumé : L'importation explicite des composants dans l'approche standalone assure la clarté, la modularité et l'optimisation de votre application Angular.

Atelier guidee, role des 4 fichiers :

a. etudiant.component.ts

Rôle : C’est le fichier TypeScript principal du composant.

Contient la classe du composant (EtudiantComponent), le sélecteur HTML (selector), le chemin du template HTML et celui du fichier CSS.

Ici, tu définis la logique du composant, les variables et les méthodes utilisées dans le HTML.

b. etudiant.component.html

Rôle : C’est le template du composant.

Contient le code HTML affiché à l’écran pour ce composant.

Ici, tu peux lier les variables et méthodes définies dans le etudiant.component.ts via data binding et event binding Angular.

c. etudiant.component.css

Rôle : Contient les styles CSS spécifiques au composant.

Les styles définis ici ne s’appliquent qu’à ce composant, grâce à l’encapsulation de styles d’Angular.

d. etudiant.component.spec.ts

Rôle : Fichier pour les tests unitaires du composant.

Contient un squelette pour tester la création du composant et ses comportements avec Jasmine/Karma.

Ce fichier est utilisé surtout lors du développement et des tests automatisés.

e. Fichier mis à jour : app.module.ts

Angular ajoute automatiquement une importation du composant et le déclare dans le module (declarations).

Permet à Angular de reconnaître le composant dans l’application.

6)
Non,  le composant n'est pas encore intégré/affiché dans l'application.

Pourquoi ?

Angular utilise l'interpolation avec la syntaxe {{ }} pour afficher les données du composant dans le template HTML.
La variable etudiant définie dans la classe TypeScript (etudiant.ts) est liée au template HTML (etudiant.html).
Lorsque Angular compile le template, il remplace {{ etudiant }} par la valeur de la propriété etudiant, c'est-à-dire 'Ali Ben Saleh'.
Pour que le changement soit visible, le composant doit être importé et utilisé dans un autre composant (comme AppComponent) via son sélecteur <app-etudiant></app-etudiant>.

Créer et manipuler une Classe Etudiant
2. Explication de chaque terme :
Export :

Permet de rendre l'interface accessible depuis d'autres fichiers du projet
Sans export, l'interface serait privée et utilisable uniquement dans le fichier où elle est déclarée
Avec export, on peut l'importer dans d'autres composants avec : import { Student } from './student'

Interface :

Définit un contrat/structure pour un objet en TypeScript
Spécifie les propriétés et leurs types qu'un objet doit avoir
Utilisée pour la vérification de type lors de la compilation (pas à l'exécution)
Ne génère aucun code JavaScript (disparaît après compilation)
Permet d'assurer que les objets respectent une structure précise


3. Différence entre les trois déclarations :
a. name: string

La propriété name est obligatoire
Elle doit être initialisée/fournie
TypeScript génère une erreur si elle est manquante

typescriptconst student: Student = { id: 1 }; // ❌ ERREUR : 'name' manquant
const student: Student = { id: 1, name: 'Ali' }; // ✅ OK
b. name!: string

Le ! est appelé "definite assignment assertion"
Indique à TypeScript : "Je garantis que cette propriété sera initialisée, fais-moi confiance"
Utilisé principalement dans les classes, pas dans les interfaces
Évite l'erreur TypeScript même si la propriété n'est pas initialisée immédiatement

typescriptclass Student {
  name!: string; // Pas d'erreur même sans initialisation

  constructor() {
    // On peut initialiser plus tard
    setTimeout(() => this.name = 'Ali', 1000);
  }
}
c. name?: string

Le ? indique que la propriété est optionnelle
Elle peut être présente ou absente
Son type est automatiquement string | undefined

typescriptconst student1: Student = { id: 1, name: 'Ali' }; // ✅ OK
const student2: Student = { id: 2 }; // ✅ OK aussi (name est optionnel)
const student3: Student = { id: 3, name: undefined }; // ✅ OK

5) Angular/JavaScript ne peut pas afficher directement un objet sous forme de texte lisible
Quand vous utilisez {{ etudiant }}, Angular essaie de convertir l'objet en chaîne de caractères
La conversion par défaut d'un objet donne "[object Object]", qui n'est pas lisible
Il faut accéder aux propriétés individuelles de l'objet pour les afficher

6) **L'affichage sera :**

---

## Ali Ben Saleh
**Id:** 1
**Name:** Ali Ben Saleh

---

7)a. Que fait le mot uppercase ?
Le pipe uppercase transforme le texte en majuscules. Il prend la valeur de etudiant.name et la convertit entièrement en lettres capitales avant de l'afficher dans le navigateur.
Syntaxe générale : {{ valeur | nomDuPipe }}

b. Pipes intégrés dans Angular :
Angular possède de nombreux pipes prédéfinis :
Pipes de transformation de texte :

uppercase - Convertit en majuscules
lowercase - Convertit en minuscules
titlecase - Met une majuscule à chaque mot

Pipes numériques :

number / decimal - Formate les nombres
percent - Affiche un nombre en pourcentage
currency - Formate en devise

Pipes de date :

date - Formate les dates

Autres pipes utiles :

json - Affiche un objet en format JSON
slice - Découpe un tableau ou une chaîne
async - Gère les Observables et Promises
keyvalue - Transforme un objet en paires clé-valeur


c. Peut-on créer des pipes personnalisés ?
Oui .

BINDING
1)Impossible de se lier à 'ngModel' car ce n'est pas une propriété connue de 'input'

Pourquoi cette erreur ?

[(ngModel)] est une directive Angular qui permet la liaison bidirectionnelle des données
Cette directive n'est pas disponible par défaut dans Angular
Elle fait partie du module FormsModule qu'il faut importer explicitement
Sans cet import, Angular ne reconnaît pas ngModel et génère une erreur

PARTIE 5

1. **b) main.ts** – C’est le fichier qui démarre l’application Angular et bootstrap le module racine.
2. **c) src/app/** – C’est le répertoire principal où on met les composants, services et autres éléments Angular.
3. **b) Définir les configurations de construction et les options pour Angular CLI.** – `angular.json` contient la configuration de build, styles globaux, assets, etc.
4. **a) Il décrit les dépendances du projet et les scripts npm disponibles.** – `package.json` sert à npm pour gérer les dépendances et les scripts.
5. **a) Configurer les options de compilation TypeScript pour le projet.** – `tsconfig.json` définit comment TypeScript compile le code.

---

Question 2 : Création et Intégration de Composants Angular

1. **c) ng generate component profil** – Commande officielle pour créer un composant.
2. **d) profil.service.ts** – Les services ne sont pas créés automatiquement avec un composant.
3. **b) @Component** – C’est le décorateur qui transforme une classe en composant Angular.
4. **a) La balise HTML personnalisée correspondant au sélecteur du composant.** – Exemple : `<app-profil></app-profil>`.
5. **a) ng generate component composants/utilisateur** – Permet de créer un dossier `composants` et un composant `utilisateur` dedans.

Question 3 : Liaison de Données Bidirectionnelle avec ngModel

1. **c) [(ngModel)]="nom"** – La syntaxe pour la liaison bidirectionnelle.
2. **b) FormsModule** – Doit être importé dans `app.module.ts` pour utiliser ngModel.
3. **b) La liaison unidirectionnelle met à jour la vue lorsque le modèle change, tandis que la bidirectionnelle synchronise automatiquement le modèle et la vue dans les deux sens.**
4. **c) @angular/forms** – ngModel fait partie du package FormsModule.
5. **b) Pour synchroniser automatiquement les données entre le modèle (composant) et la vue (template).**

Question 4 : l’AppModule

1. **c) Il déclare les composants, directives, et pipes, et importe les modules nécessaires.**
2. **a) @NgModule** – Décorateur pour définir un module Angular.
3. **b) imports** – Les modules comme FormsModule doivent être ajoutés ici.
4. **c) Les fonctionnalités liées au module manquant ne fonctionneront pas, et des erreurs pourraient survenir à l’exécution.**
5. **b) app.module.ts** – Contient la définition par défaut du module racine.

Question 5 : Déclaration des composants dans l’AppModule

1. **a) Pour que les composants puissent être utilisés dans les templates d'autres composants du même module.**
2. **b) declarations** – Tableau pour déclarer les composants, directives et pipes.
3. **b) Angular génère une erreur indiquant que le composant n'est pas une entité connue.**
4. **b) Non, un composant ne peut être déclaré que dans un seul module.**
5. **b) Créer des modules fonctionnels ou de fonctionnalités pour regrouper les composants liés et déclarer les composants dans ces modules.**


1. Rôle de app.component.ts

   * Contient la logique du composant racine et son template (`app.component.html`).
   * Il est déclaré dans `app.module.ts`, qui le reconnait comme composant.
   * `main.ts` démarre l’application et bootstrape l’AppModule, donc indirectement `app.component.ts` est chargé.

2. Processus de création d’un composant Angular

   * Commande : `ng generate component nomDuComposant`
   * Crée automatiquement : `.ts` (logique), `.html` (template), `.css` (styles), `.spec.ts` (tests).
   * Ajouter le composant dans `app.module.ts` si nécessaire.
   * Intégrer dans le parent via la balise HTML correspondant au sélecteur.

3. Importance d’importer FormsModule pour ngModel

   * FormsModule contient les directives pour les formulaires, dont ngModel.
   * Permet la liaison bidirectionnelle entre le modèle (composant) et le template.
   * Sans l’import, Angular ne reconnait pas ngModel et génère une erreur.

4. Liaison de données bidirectionnelle

   * Synchronise automatiquement le modèle et la vue.
   * Exemple :

     ```html
     <input [(ngModel)]="nom">
     <p>Bonjour {{ nom }}</p>
     ```

     * Si l’utilisateur tape dans l’input, `nom` est mis à jour et le texte change automatiquement.

5. Conséquences de ne pas déclarer un composant

   * Angular ne reconnait pas le composant.
   * Erreur : “Component is not a known element”.
   * L’application ne compile pas correctement et le composant ne s’affiche pas.



